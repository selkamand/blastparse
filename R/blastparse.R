#' Parse Blast Outputs
#'
#' Parses blast outputs produced by [blast_run()]
#'
#' @param blast_path path to tabular blast file (produced by [blast_run()])
#' @param strong_hit_evalue,strong_hit_perc_identity,strong_hit_query_coverage, BLAST alignments are considered 'strong hits' if the alignment has an E-value > strong_hit_evalue, a percentage identity > strong_hit_perc_identity, and a query coverage of > strong_hit_query_coverage.
#' @param blast_config_path path to config file describing parameters used to run blastn
#' @param skip_sciname_mapping Don't attempt to map taxids to scientific names. This prevents downstream microbial analysis but can be useful if you just want to parse blast results generated using a local custom database lacking taxonomy information
#' @param blast_seqnames_path path to a file listing the names of your query sequences. This file is autogenerated by [blast_run()] and will be automatically found based on the blast_path unless the name has manually been changed
#'
#' @return Blast object
#' @export
blast_parse <- function(blast_path, blast_config_path = blast_path_to_config_path_guess(blast_path), blast_seqnames_path = blast_path_to_seqname_path_guess(blast_path), strong_hit_evalue = 1e-50, strong_hit_perc_identity = 97, strong_hit_query_coverage = 95, skip_sciname_mapping = FALSE){

  # Check all files exist
  utilitybeltfmt::message_info("Checking files exist ... ")
  assertions::assert_all_files_exist(blast_path)
  assertions::assert_all_files_exist(blast_config_path)
  assertions::assert_all_files_exist(blast_seqnames_path)


  utilitybeltfmt::message_success("found blast output, config file, and seqnames", level = 2)

  # Read config file
  utilitybeltfmt::message_info("Reading config file ... ")
  blast_config_df <-  dplyr::tibble(utils::read.csv(blast_config_path, header = FALSE, sep = "\t", col.names = c("Property", "Value"), colClasses = c("character","character")))
  assertthat::assert_that(nrow(blast_config_df) > 0, msg = "blast config file is empty")

  valid_blast_config_fields = blast_valid_config_fields()

  valid_blast_column_names = c("bitscore", "btop", "evalue", "gapopen", "length", "mismatch",
                               "pident", "qaccver", "qcovhsp", "qcovs", "qcovus", "qend", "qstart",
                               "saccver", "salltitles", "sblastname", "sblastnames", "scomname",
                               "scomnames", "send", "sframe", "ssciname", "sscinames", "sskingdom",
                               "sskingdoms", "sstart", "sstrand", "staxid", "staxids", "stitle"
  )

  # Ensure all fields in config file are valid
  utilitybeltassertions::assert_all_values_are_in_set(
    test_values = blast_config_df[["Property"]],
    acceptable_values = valid_blast_config_fields
  )

  # Ensure all required fields in config file are present
  assertthat::assert_that(
    all(valid_blast_config_fields %in% blast_config_df[["Property"]]),
    msg = utilitybeltfmt::fmterror("Config file requires the following missing fields: \n", paste0("\t\t> ", valid_blast_config_fields[! valid_blast_config_fields %in% blast_config_df[["Property"]]], collapse = "\n"))
  )
  utilitybeltfmt::message_success("blast config file contains all expected fields ", level = 2)

  # Make sure no duplicate fields are present
  assertthat::assert_that(anyDuplicated(blast_config_df[["Value"]])==0, msg = utilitybeltfmt::fmterror("Found duplicate properties in blast config file: ", blast_config_df[["Value"]][duplicated(blast_config_df[["Value"]])]))

  # Extract blast column names
  utilitybeltfmt::message_info("Extracting blast output column names from config file ... ")

  outfmt = blast_config_df[["Value"]][blast_config_df[["Property"]]=="outfmt"]
  outfmt_vectorised = unlist(strsplit(outfmt, split = " "))

  assertthat::assert_that(outfmt_vectorised[1] == "6", msg = utilitybeltfmt::fmterror("We only support outfmt 6. If you have used outfmt 6 and stil see this message - make sure the first entry in the 'outfmt' field of your config file is being correctly set to '6'"))
  utilitybeltfmt::message_success("config file says outfmt type is '6' (supported)", level = 2)

  # Converting 'std' to list of headings it represents (and drop first element which corresponds to the type of outfmt used ..e.g '6' for tabular
  blastn_headings = sub(x = outfmt_vectorised[-1], pattern = "^std$", replacement = "qaccver saccver pident length mismatch gapopen qstart qend sstart send evalue bitscore")
  blastn_headings = unlist(strsplit(x=blastn_headings, split = " "))

  # Make sure our headings are all unique
  assertthat::assert_that(anyDuplicated(blastn_headings) == 0, msg = utilitybeltfmt::fmterror("Duplicated blast headings in config file: ", blastn_headings[duplicated(blastn_headings)]))

  # Make sure our headings (from config file are valid blast headings)
  utilitybeltassertions::assert_all_values_are_in_set(blastn_headings,valid_blast_column_names, name = "blastn headings described in config file")

  # Read blast output
  utilitybeltfmt::message_info("Reading blast file")
  blast_df = data.table::fread(file = blast_path, header = FALSE)

  #Make sure number of columns in blastdf matches whats expected given outfmt headings line of config file
  assertthat::assert_that(length(blastn_headings) == ncol(blast_df), msg = utilitybeltfmt::fmterror(
    "The number of columns expected based on config file [", length(blastn_headings), "] was different to the number of columns in the blast file itself [",ncol(blast_df),"]"
    ))

  #Make sure required blast headings are included
  required_blast_columns = c("bitscore","evalue", "pident", "qaccver", "qcovhsp", "qcovs","saccver", "stitle", "staxid")
  assertthat::assert_that(all(required_blast_columns %in% blastn_headings), msg = utilitybeltfmt::fmterror(
    "This package requires certain columns to be present in the blast results. Please add [",
    paste0(required_blast_columns[! required_blast_columns  %in% blastn_headings], collapse = " "),
    "] to the end of your blast -outfmt argument"
    )
  )

  names(blast_df) <- blastn_headings
  utilitybeltfmt::message_success("succesfully read blast file", level = 2)

  # Add some blast headings we care about

  ## Classify 'strong hits' (If you change this code also change documentation of Blast class
  utilitybeltfmt::message_info("Identifying strong hits using the following formula:")
  utilitybeltfmt::message_info(
    "Strong Hit = evalue < ",strong_hit_evalue,
    " & perc_identity > ",strong_hit_perc_identity,
    " & qcovs > ",strong_hit_query_coverage,
    level = 2,
    symbol = FALSE
  )
  blast_df[,strong_hit := blast_df[["evalue"]] < strong_hit_evalue &
             blast_df[["pident"]] > strong_hit_perc_identity &
             blast_df[["qcovs"]] > strong_hit_query_coverage
           ]
  queries_with_at_least_one_strong_hit = dplyr::n_distinct(blast_df[["qaccver"]][blast_df[["strong_hit"]]])
  utilitybeltfmt::message_success("Identified at least one strong hit for [", queries_with_at_least_one_strong_hit , "] query sequences", level = 2)

  ## Rank each hit per query (replace with native data.table immplementation
  utilitybeltfmt::message_info("Ranking hits within each query")
  blast_df <- blast_df |>
    dplyr::tibble() |>
    dplyr::group_by(qaccver) |>
    dplyr::mutate(hit_rank = blast_rank_hits(evalue, pident, qcovs)) |>
    dplyr::ungroup() |>
    data.table::as.data.table()
  blast_df[, top_hit_for_query := hit_rank == min(hit_rank), by = .(qaccver)]
  message("\t", utilitybeltfmt::fmtsuccess("Succesfully ranked hits for each query"))
  ## ^ note that at this stage there can still be multiple tophits per query sequence. To get 1 tophit per query run blast_top_hits on blast object

  ## Convert Taxids To Scientific Names
  utilitybeltfmt::message_info("Converting taxids to scientific names")

  if(!skip_sciname_mapping){
    blast_df[,scientific_name := taxid2name(blast_df[["staxid"]])]
    blast_df[,scientific_name_species := taxid2name(taxid_to_higher_ranked_taxid(blast_df[["staxid"]], rank = "species"))]
    blast_df[,scientific_name_genus := taxid2name(taxid_to_higher_ranked_taxid(blast_df[["staxid"]], rank = "genus"))]
    blast_df[,scientific_name_superkingdom := taxid2name(taxid_to_higher_ranked_taxid(blast_df[["staxid"]], rank = "superkingdom"))]

    ### Add lineage path (will be important for sunburst plot)
    blast_df[,lineage := taxid2lineage(blast_df[["staxid"]], end_lineage_with_empty_string=FALSE)]

    ## Make sure all taxids could be mapped to a scientific name
    unmapped_taxids = unique(blast_df[["staxid"]][is.na(blast_df[["scientific_name"]])])
    num_unmapped_taxids = dplyr::n_distinct(unmapped_taxids)
    if(num_unmapped_taxids > 0){
      message("\t", fmt::fmterror("failed to map [",num_unmapped_taxids, "] taxid/s to their scientific name"))

      if(num_unmapped_taxids < 10)
        fmt::message_error("failed taxids: ", paste0(unmapped_taxids, collapse = ","), symbol = FALSE)

      fmt::message_error("\n\tIf you suspect the failed taxids truly exist, try updating the taxizedb ncbi database and try again. If you are not interested in the species from which hits are derived, set skip_sciname_mapping=TRUE", symbol = FALSE)
      stop()
    }
    else{
      message("\t", fmt::fmtsuccess("Succesfully mapped all taxids to their scientific names"))
    }

  }
  ## Extract config details
  blast_config_list = as.list(tidyr::pivot_wider(blast_config_df, names_from = "Property", values_from = "Value"))

  ## Read seqnames file
  seqnames_vector = readLines(blast_seqnames_path)

  ## Assert that all query sequences in blast file have a name in seqnames file
  utilitybeltfmt::message_info("Reading Seqname file")
  assertthat::assert_that(
    all(unique(blast_df[["qaccver"]]) %in% seqnames_vector), msg = utilitybeltfmt::fmterror(level = 2,
      "Not all sequence names in blast output are included in the seqnames file [", blast_seqnames_path,"].
      The following sequences are missing: \n", paste0(blast_df[["qaccver"]][! blast_df[["qaccver"]] %in% seqnames_vector], collapse = ", ")
      )
    )
  utilitybeltfmt::message_success(level = 2, "All names in blast results are present in seqname file")

  # Assert that names in Seqnames file are unique
  assertthat::assert_that(
    anyDuplicated(seqnames_vector) == 0, msg = utilitybeltfmt::fmterror(
      "Duplicate sequence names found: \n", paste0(seqnames_vector[duplicated(seqnames_vector)], collapse = ", ")
      , level = 2)
    )

  ## Assert that number of names in seqnames file matches numsequences blasted in config file
  assertthat::assert_that(
    as.numeric(blast_config_list[["num_seqs_blasted"]]) == length(seqnames_vector),
    msg = utilitybeltfmt::fmterror(
      "The number of sequences blasted according to your config file [",
      blast_config_list[["num_seqs_blasted"]],
      "] doesn't match the number of sequence names in your seqnames file [",length(seqnames_vector),"]"
      ))
  utilitybeltfmt::message_success(level = 2, "# of names in seqnames file = number blasted according to config file")

  ## Create Blast S4 Object
  utilitybeltfmt::message_info("Creating blast object")
  blast <- BlastInstantiate(
    blast_df = blast_df,
    blast_config = blast_config_list,
    strong_hit_evalue = strong_hit_evalue,
    strong_hit_perc_identity = strong_hit_perc_identity,
    strong_hit_query_coverage = strong_hit_query_coverage,
    names_of_query_sequences = seqnames_vector
  )
  utilitybeltfmt::message_success(level = 2, "Blast object successfully created")
  return(blast)
}



# Finding Files -----------------------------------------------------------
blast_path_to_config_path_guess <- function(blast_path){
  assertthat::assert_that(any(grepl(blast_path, pattern = "blastn.tsv")), msg = utilitybeltfmt::fmterror(
    "Could not find blastn.tsv in supplied blast_path. This package expects suffix of blast files to be blastn.tsv"
    ))
  sub(blast_path, pattern = "blastn.tsv", replacement = "blastn.config.tsv", fixed = TRUE)
}

blast_path_to_seqname_path_guess <- function(blast_path){
  assertthat::assert_that(any(grepl(blast_path, pattern = "blastn.tsv")), msg = utilitybeltfmt::fmterror(
    "Could not find blastn.tsv in supplied blast_path. This package expects suffix of blast files to be blastn.tsv"
  ))
  sub(blast_path, pattern = "blastn.tsv", replacement = "blastn.seqnames.tsv", fixed = TRUE)
}



# Ranking Functions -------------------------------------------------------
blast_rank_hits <- function(evalue, pident, qcovs){
  return(rank(rank(evalue) + rank(-pident) + rank(-qcovs)))
}



# Taxonomy ----------------------------------------------------------------


#' NCBI Taxid to Scientific Name
#'
#' Faster taxid2name for long vectors with repeated taxids
#'
#' @param taxids vector of taxids (numeric)
#'
#' @return scientific names for each taxid, or NA if no taxanomic match could be found
#' @export
taxid2name <- function(taxids){
  taxids_valid_uniq <- unique(na.omit(suppressWarnings(as.numeric(taxids))))
  if(length(taxids_valid_uniq) == 0) return(rep(NA_character_, times = length(taxids)))

  scinames_unique = taxizedb::taxid2name(x = taxids_valid_uniq,db = "ncbi", warn = FALSE)
  names(scinames_unique) <- taxids_valid_uniq
  taxid_scinames <- scinames_unique[match(taxids, names(scinames_unique))]
  #taxid_scinames_fixed = ifelse(is.na(taxid_scinames), taxids, taxid_scinames)
  return(taxid_scinames)
}



#' Taxid
#'
#' Takes a taxid and returns the parent taxid that matches the specified rank. If taxid is already that rank (or higher), will return the taxid unchanged
#'
#' @param taxids ncbi taxonomy ID
#' @param rank what rank you're interested in (e.g. species, genus or family)
#'
#' @return first parent taxid at supplied rank or the input taxid if its already at this rank / higher  (string)
#' @export
#'
taxid_to_higher_ranked_taxid <- function(taxids, rank = c("species", "genus", "family", "order", "class", "clade", "phylum", "kingdom", "superkingdom")){
  rank = rlang::arg_match(rank)
  taxids_valid_uniq <- unique(na.omit(suppressWarnings(as.numeric(taxids))))
  if(length(taxids_valid_uniq) == 0) return(rep(NA_character_, times = length(taxids)))

  r=taxizedb::classification(x = taxids_valid_uniq)
  taxid_to_rank_level_mapping <- sapply(r, function(x) { if(any(is.na(x))) {return(NA)}; x$id[match(rank, x$rank)] })

  rank_level_taxids = taxid_to_rank_level_mapping[match(taxids, names(taxid_to_rank_level_mapping))]

  rank_level_taxids_fixed = ifelse(is.na(rank_level_taxids), yes = taxids, no = rank_level_taxids)
  return(rank_level_taxids_fixed)
}

taxid2lineage <- function(taxids, ranks_to_include = c("species", "genus", "superkingdom"), end_lineage_with_empty_string = TRUE) {
  r=taxizedb::classification(x = unique(taxids), db = "ncbi", verbose = FALSE)
  taxid_lineage = sapply(r, FUN = function(classification_df){
    if(any(is.na(classification_df))) return("")
    taxid_lineage = classification_df[["id"]][classification_df[["rank"]] %in% c(ranks_to_include)]


    taxid_lineage_names = taxid2name(taxid_lineage)

    if(end_lineage_with_empty_string)
      taxid_lineage_names = vctrs::vec_c("", taxid_lineage_names, .ptype = character(0))
    else
      taxid_lineage_names = taxid_lineage_names

    taxid_lineage_names = paste0(taxid_lineage_names, collapse = ",")

    return(taxid_lineage_names)
  })

  lineage = taxid_lineage[match(taxids, names(taxid_lineage))]
  return(lineage)

}


