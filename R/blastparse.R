#' Parse Blast Outputs
#'
#' Parses blast outputs produced by [blast_run()]
#'
#' @param blast_path path to tabular blast file (produced by [blast_run()])
#' @param strong_hit_evalue,strong_hit_perc_identity,strong_hit_query_coverage, BLAST alignments are considered 'strong hits' if the alignment has an E-value > strong_hit_evalue, a percentage identity > strong_hit_perc_identity, and a query coverage of > strong_hit_query_coverage.
#' @param blast_config_path path to config file describing parameters used to run blastn
#' @param blast_seqnames_path path to a file listing the names of your query sequences. This file is autogenerated by [blast_run()] and will be automatically found based on the blast_path unless the name has manually been changed
#'
#' @return Blast object
#' @export
blast_parse <- function(blast_path, blast_config_path = blast_path_to_config_path_guess(blast_path), blast_seqnames_path = blast_path_to_seqname_path_guess(blast_path), strong_hit_evalue = 1e-50, strong_hit_perc_identity = 97, strong_hit_query_coverage = 95){

  #browser()
  # Check all files exist
  utilitybeltfmt::message_info("Checking files exist ... ")
  assertions::assert_all_files_exist(blast_path)
  assertions::assert_all_files_exist(blast_config_path)
  assertions::assert_all_files_exist(blast_seqnames_path)


  utilitybeltfmt::message_success("found blast output, config file, and seqnames", level = 2)

  # Read config file
  utilitybeltfmt::message_info("Reading config file ... ")
  blast_config_df <-  dplyr::tibble(utils::read.csv(blast_config_path, header = FALSE, sep = "\t", col.names = c("Property", "Value"), colClasses = c("character","character")))
  assertthat::assert_that(nrow(blast_config_df) > 0, msg = "blast config file is empty")

  valid_blast_config_fields = blast_valid_config_fields()

  valid_blast_column_names = c("bitscore", "btop", "evalue", "gapopen", "length", "mismatch",
                               "pident", "qaccver", "qcovhsp", "qcovs", "qcovus", "qend", "qstart",
                               "saccver", "salltitles", "sblastname", "sblastnames", "scomname",
                               "scomnames", "send", "sframe", "ssciname", "sscinames", "sskingdom",
                               "sskingdoms", "sstart", "sstrand", "staxid", "staxids", "stitle"
  )

  # Ensure all fields in config file are valid
  utilitybeltassertions::assert_all_values_are_in_set(
    test_values = blast_config_df[["Property"]],
    acceptable_values = valid_blast_config_fields
  )

  # Ensure all required fields in config file are present
  assertthat::assert_that(
    all(valid_blast_config_fields %in% blast_config_df[["Property"]]),
    msg = utilitybeltfmt::fmterror("Config file requires the following missing fields: \n", paste0("\t\t> ", valid_blast_config_fields[! valid_blast_config_fields %in% blast_config_df[["Property"]]], collapse = "\n"))
  )
  utilitybeltfmt::message_success("blast config file contains all expected fields ", level = 2)

  # Make sure no duplicate fields are present
  assertthat::assert_that(anyDuplicated(blast_config_df[["Value"]])==0, msg = utilitybeltfmt::fmterror("Found duplicate properties in blast config file: ", blast_config_df[["Value"]][duplicated(blast_config_df[["Value"]])]))

  # Extract blast column names
  utilitybeltfmt::message_info("Extracting blast output column names from config file ... ")

  outfmt = blast_config_df[["Value"]][blast_config_df[["Property"]]=="outfmt"]
  outfmt_vectorised = unlist(strsplit(outfmt, split = " "))

  assertthat::assert_that(outfmt_vectorised[1] == "6", msg = utilitybeltfmt::fmterror("We only support outfmt 6. If you have used outfmt 6 and stil see this message - make sure the first entry in the 'outfmt' field of your config file is being correctly set to '6'"))
  utilitybeltfmt::message_success("config file says outfmt type is '6' (supported)", level = 2)

  # Converting 'std' to list of headings it represents (and drop first element which corresponds to the type of outfmt used ..e.g '6' for tabular
  blastn_headings = sub(x = outfmt_vectorised[-1], pattern = "^std$", replacement = "qaccver saccver pident length mismatch gapopen qstart qend sstart send evalue bitscore")
  blastn_headings = unlist(strsplit(x=blastn_headings, split = " "))

  # Make sure our headings are all unique
  assertthat::assert_that(anyDuplicated(blastn_headings) == 0, msg = utilitybeltfmt::fmterror("Duplicated blast headings in config file: ", blastn_headings[duplicated(blastn_headings)]))

  # Make sure our headings (from config file are valid blast headings)
  utilitybeltassertions::assert_all_values_are_in_set(blastn_headings,valid_blast_column_names, name = "blastn headings described in config file")

  # Read blast output
  utilitybeltfmt::message_info("Reading blast file")
  blast_df = data.table::fread(file = blast_path, header = FALSE)

  #Make sure number of columns in blastdf matches whats expected given outfmt headings line of config file
  assertthat::assert_that(length(blastn_headings) == ncol(blast_df), msg = utilitybeltfmt::fmterror(
    "The number of columns expected based on config file [", length(blastn_headings), "] was different to the number of columns in the blast file itself [",ncol(blast_df),"]"
    ))

  #Make sure required blast headings are included
  required_blast_columns = c("bitscore","evalue", "pident", "qaccver", "qcovhsp", "qcovs","saccver", "stitle", "staxid")
  assertthat::assert_that(all(required_blast_columns %in% blastn_headings), msg = utilitybeltfmt::fmterror(
    "This package requires certain columns to be present in the blast results. Please add [",
    paste0(required_blast_columns[! required_blast_columns  %in% blastn_headings], collapse = " "),
    "] to the end of your blast -outfmt argument"
    )
  )

  names(blast_df) <- blastn_headings
  utilitybeltfmt::message_success("succesfully read blast file", level = 2)

  # Add some blast headings we care about

  ## Classify 'strong hits' (If you change this code also change documentation of Blast class
  utilitybeltfmt::message_info("Identifying strong hits using the following formula:")
  utilitybeltfmt::message_info(
    "Strong Hit = evalue < ",strong_hit_evalue,
    " & perc_identity > ",strong_hit_perc_identity,
    " & qcovs > ",strong_hit_query_coverage,
    level = 2,
    symbol = FALSE
  )
  blast_df[,strong_hit := blast_df[["evalue"]] < strong_hit_evalue &
             blast_df[["pident"]] > strong_hit_perc_identity &
             blast_df[["qcovs"]] > strong_hit_query_coverage
           ]
  queries_with_at_least_one_strong_hit = dplyr::n_distinct(blast_df[["qaccver"]][blast_df[["strong_hit"]]])
  utilitybeltfmt::message_success("Identified at least one strong hit for [", queries_with_at_least_one_strong_hit , "] query sequences", level = 2)

  ## Rank each hit per query (replace with native data.table immplementation
  utilitybeltfmt::message_info("Ranking hits within each query")
  blast_df <- blast_df |>
    dplyr::tibble() |>
    dplyr::group_by(qaccver) |>
    dplyr::mutate(hit_rank = blast_rank_hits(evalue, pident, qcovs)) |>
    dplyr::ungroup() |>
    data.table::as.data.table()
  blast_df[, top_hit_for_query := hit_rank == min(hit_rank), by = .(qaccver)]
  message("\t", utilitybeltfmt::fmtsuccess("Succesfully ranked hits for each query"))
  ## ^ note that at this stage there can still be multiple tophits per query sequence. To get 1 tophit per query run blast_top_hits on blast object

  ## Convert Taxids To Scientific Names
  utilitybeltfmt::message_info("Converting taxids to scientific names")
  blast_df[,scientific_name := taxid2name(blast_df[["staxid"]])]
  blast_df[,scientific_name_species := taxid2name(taxid_to_higher_ranked_taxid(blast_df[["staxid"]], rank = "species"))]
  blast_df[,scientific_name_genus := taxid2name(taxid_to_higher_ranked_taxid(blast_df[["staxid"]], rank = "genus"))]
  blast_df[,scientific_name_superkingdom := taxid2name(taxid_to_higher_ranked_taxid(blast_df[["staxid"]], rank = "superkingdom"))]

  ### Add lineage path (will be important for sunburst plot)
  blast_df[,lineage := taxid2lineage(blast_df[["staxid"]], end_lineage_with_empty_string=FALSE)]

  ## Make sure all taxids could be mapped to a scientific name
  unmapped_taxids = unique(blast_df[["staxid"]][is.na(blast_df[["scientific_name"]])])
  num_unmapped_taxids = dplyr::n_distinct(unmapped_taxids)
  if(num_unmapped_taxids > 0){
    message("\t", utilitybeltfmt::fmterror("failed to map [",num_unmapped_taxids, "] taxid/s to their scientific name"))

    if(num_unmapped_taxids < 10)
      utilitybeltfmt::message_error("failed taxids: ", paste0(unmapped_taxids, collapse = ","), symbol = FALSE)

    utilitybeltfmt::message_error("\n\tI would highly advise to update the taxizedb ncbi database and try again", symbol = FALSE)
    stop()
  }
  else{
    message("\t", utilitybeltfmt::fmtsuccess("Succesfully mapped all taxids to their scientific names"))
  }

  ## Extract config details
  blast_config_list = as.list(tidyr::pivot_wider(blast_config_df, names_from = "Property", values_from = "Value"))

  ## Read seqnames file
  seqnames_vector = readLines(blast_seqnames_path)

  ## Assert that all query sequences in blast file have a name in seqnames file
  utilitybeltfmt::message_info("Reading Seqname file")
  assertthat::assert_that(
    all(unique(blast_df[["qaccver"]]) %in% seqnames_vector), msg = utilitybeltfmt::fmterror(level = 2,
      "Not all sequence names in blast output are included in the seqnames file [", blast_seqnames_path,"].
      The following sequences are missing: \n", paste0(blast_df[["qaccver"]][! blast_df[["qaccver"]] %in% seqnames_vector], collapse = ", ")
      )
    )
  utilitybeltfmt::message_success(level = 2, "All names in blast results are present in seqname file")

  # Assert that names in Seqnames file are unique
  assertthat::assert_that(
    anyDuplicated(seqnames_vector) == 0, msg = utilitybeltfmt::fmterror(
      "Duplicate sequence names found: \n", paste0(seqnames_vector[duplicated(seqnames_vector)], collapse = ", ")
      , level = 2)
    )

  ## Assert that number of names in seqnames file matches numsequences blasted in config file
  assertthat::assert_that(
    as.numeric(blast_config_list[["num_seqs_blasted"]]) == length(seqnames_vector),
    msg = utilitybeltfmt::fmterror(
      "The number of sequences blasted according to your config file [",
      blast_config_list[["num_seqs_blasted"]],
      "] doesn't match the number of sequence names in your seqnames file [",length(seqnames_vector),"]"
      ))
  utilitybeltfmt::message_success(level = 2, "# of names in seqnames file = number blasted according to config file")

  ## Create Blast S4 Object
  utilitybeltfmt::message_info("Creating blast object")
  blast <- BlastInstantiate(
    blast_df = blast_df,
    blast_config = blast_config_list,
    strong_hit_evalue = strong_hit_evalue,
    strong_hit_perc_identity = strong_hit_perc_identity,
    strong_hit_query_coverage = strong_hit_query_coverage,
    names_of_query_sequences = seqnames_vector
  )
  utilitybeltfmt::message_success(level = 2, "Blast object successfully created")
  return(blast)
}



# Finding Files -----------------------------------------------------------
blast_path_to_config_path_guess <- function(blast_path){
  assertthat::assert_that(any(grepl(blast_path, pattern = "blastn.tsv")), msg = utilitybeltfmt::fmterror(
    "Could not find blastn.tsv in supplied blast_path. This package expects suffix of blast files to be blastn.tsv"
    ))
  sub(blast_path, pattern = "blastn.tsv", replacement = "blastn.config.tsv", fixed = TRUE)
}

blast_path_to_seqname_path_guess <- function(blast_path){
  assertthat::assert_that(any(grepl(blast_path, pattern = "blastn.tsv")), msg = utilitybeltfmt::fmterror(
    "Could not find blastn.tsv in supplied blast_path. This package expects suffix of blast files to be blastn.tsv"
  ))
  sub(blast_path, pattern = "blastn.tsv", replacement = "blastn.seqnames.tsv", fixed = TRUE)
}



# Ranking Functions -------------------------------------------------------
blast_rank_hits <- function(evalue, pident, qcovs){
  return(rank(rank(evalue) + rank(-pident) + rank(-qcovs)))
}



# Taxonomy ----------------------------------------------------------------


#' NCBI Taxid to Scientific Name
#'
#' Faster taxid2name for long vectors with repeated taxids
#'
#' @param taxids vector of taxids (numeric)
#'
#' @return scientific names for each taxid, or NA if no taxanomic match could be found
#' @export
taxid2name <- function(taxids){
  scinames_unique = taxizedb::taxid2name(x = unique(taxids),db = "ncbi", warn = FALSE)
  names(scinames_unique) <- unique(taxids)
  taxid_scinames <- scinames_unique[match(taxids, names(scinames_unique))]
  #taxid_scinames_fixed = ifelse(is.na(taxid_scinames), taxids, taxid_scinames)
  return(taxid_scinames)
}



#' Taxid
#'
#' Takes a taxid and returns the parent taxid that matches the specified rank. If taxid is already that rank (or higher), will return the taxid unchanged
#'
#' @param taxids ncbi taxonomy ID
#' @param rank what rank you're interested in (e.g. species, genus or family)
#'
#' @return first parent taxid at supplied rank or the input taxid if its already at this rank / higher  (string)
#' @export
#'
taxid_to_higher_ranked_taxid <- function(taxids, rank = c("species", "genus", "family", "order", "class", "clade", "phylum", "kingdom", "superkingdom")){
  rank = rlang::arg_match(rank)

  r=taxizedb::classification(x = unique(taxids))
  taxid_to_rank_level_mapping <- sapply(r, function(x) { if(any(is.na(x))) {return(NA)}; x$id[match(rank, x$rank)] })

  rank_level_taxids = taxid_to_rank_level_mapping[match(taxids, names(taxid_to_rank_level_mapping))]

  rank_level_taxids_fixed = ifelse(is.na(rank_level_taxids), yes = taxids, no = rank_level_taxids)
  return(rank_level_taxids_fixed)
}

taxid2lineage <- function(taxids, ranks_to_include = c("species", "genus", "superkingdom"), end_lineage_with_empty_string = TRUE) {
  r=taxizedb::classification(x = unique(taxids), db = "ncbi", verbose = FALSE)
  taxid_lineage = sapply(r, FUN = function(classification_df){
    if(any(is.na(classification_df))) return("")
    taxid_lineage = classification_df[["id"]][classification_df[["rank"]] %in% c(ranks_to_include)]


    taxid_lineage_names = taxid2name(taxid_lineage)

    if(end_lineage_with_empty_string)
      taxid_lineage_names = vctrs::vec_c("", taxid_lineage_names, .ptype = character(0))
    else
      taxid_lineage_names = taxid_lineage_names

    taxid_lineage_names = paste0(taxid_lineage_names, collapse = ",")

    return(taxid_lineage_names)
  })

  lineage = taxid_lineage[match(taxids, names(taxid_lineage))]
  return(lineage)

}


